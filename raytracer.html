<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" type="text/css" href="/static/style.css">
</head>

<body>

    <!--navbar-->
    <ul>
        <li><a href="/">About Me</a></li>
        <li><a>About This Site</a></li>
        <li class="dropdown">
            <a class="dropbtn">Project Articles</a>
            <div class="dropdown-content">
                <a href="#">Raytracer</a>
                <a>Naive Bayes Classifier</a>
            </div>
        </li>
        <li class="dropdown">
            <a class="dropbtn">Interactive Projects</a>
            <div class="dropdown-content">
                <a>Linear Regression Model</a>
                <a>Connect 4 Bot - Video Demo</a>
            </div>
        </li>
    </ul>
    <!--navbar-->

    <figure>
    <h1>Building A Multithreaded Raytracer From Scratch</h1>
    <figcaption><a target="_blank" href="https://github.com/HiddenToad/raytracer-rs" style="font-size: 1.2em !important;">Github Repo Link</a></figcaption>
    </figure>
    <br><br>
    <div class="articletext">
        <h2>What is raytracing?</h2>
        <p>Raytracing is a type of 3D rendering where the shapes are rendered by tracing the paths of simulated "rays" of light through the scene. This allows for more realistic, naturally lit images with shadows, reflections, and textures all looking
            more realistically illuminated. Many modern video games have support for real-time raytracing, and nearly every 3D animated movie in the past couple decades has used it. Pixar Animation Studios first used a raytracing renderer in the 2006
            movie <cite>Cars</cite>.
        </p>
        <br/>
        <figure>
            <img src="static/raytracer/kachow.jpg" class="articleimage"/>
            <figcaption>Raytraced lighting in <cite>Cars (2006)</cite> gives the body of the protagonist a polished, glossy feel.</figcaption>
        </figure>
        <br/>
        <h2>Features</h2>
        <p>
            The raytracer I created is pretty limited in function. To start off, it can only render spheres. The formula for a ray's collision with a sphere was complicated enough for me to implement as it is; to implement it to work with an arbitrary
            3D model would be beyond the scope of my time or abilities. There are 2 materials a rendered sphere can be: Lambertian (a matte solid) and metallic (shiny metal that reflects and blurs). I tried implementing dielectrics (something that
            is see through but refracts, like glass or water) but couldn't get it to look right. For any sphere, you can choose its position, radius, color, and material, as well as blur for metal spheres. The camera is pretty full-feature: you can 
            set field of view, position, position to look at, lens aperture (which mainly affects the depth-of-field blur affect), and the distance from the lens to focus on. 
        </p>
        <p>
            The other feature that I implemented for the renderer is concurrency. Concurrency, also known as multithreading, means that instead of your computer following each step of a task
            in a row, it will split up the task into multiple parts that can be handled simultaneously by different threads of the CPU. Think of it like hiring multiple workers to do different parts of a complex job, versus having one guy do it all alone.
            This can be a game-changer for intense tasks that have a lot of repetitive steps, like rendering. Making my raytracer concurrent dropped my render times by nearly 25%. I'll go more into how I did this later in the article.
        </p>

        <br><br>
        <h2>Basic rendering</h2>
        <figure>
            <img src="static/raytracer/lone-sphere-256s.png" class="articleimage">
            <figcaption>A single red sphere rendered on an empty plane.</figcaption>
        </figure>
        <p>
            I'm not going to go into the specific math behind the rendering; it would be outside the scope of this article. The basic method for re
        </p>
        
    </div>

</body>
</html>